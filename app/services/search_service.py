import logging
import json
from typing import List, Tuple, Dict, Any
from pymilvus import Collection
from app.services.embedding_service import EmbeddingService
from app.services.milvus_service import MilvusService
import time

# Configuration du logger
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

class SearchService:
    def __init__(self, milvus_service: MilvusService, embedding_service: EmbeddingService, top_k: int = 5):
        self.milvus_service = milvus_service
        self.embedding_service = embedding_service
        self.top_k = top_k

    def search(self, query: str, top_k: int = None, filter_expr: str = None) -> List[Dict[str, Any]]:
        """
        Recherche des documents pertinents pour la requ√™te.
        
        Args:
            query: La requ√™te de l'utilisateur
            top_k: Nombre maximal de r√©sultats √† retourner (utilise la valeur par d√©faut de la classe si None)
            filter_expr: Expression de filtrage Milvus optionnelle
            
        Returns:
            Liste de dictionnaires contenant les documents trouv√©s avec leurs m√©tadonn√©es
        """
        try:
            start_time = time.time()
            logger.info(f"üîé Recherche des documents pour la requ√™te : {query}")
            
            # Utiliser top_k de la requ√™te ou la valeur par d√©faut
            actual_top_k = top_k if top_k is not None else self.top_k
            
            # G√©n√©ration de l'embedding
            embedding_start = time.time()
            query_embeddings = self.embedding_service.generate_embeddings([query])
            if not query_embeddings or len(query_embeddings) == 0:
                logger.error("‚ùå Aucun embedding g√©n√©r√© pour la requ√™te.")
                return []
                
            query_embedding = query_embeddings[0]
            embedding_time = time.time() - embedding_start
            logger.info(f"‚è±Ô∏è Temps de g√©n√©ration de l'embedding : {embedding_time:.3f}s")
            
            # Recherche dans Milvus
            search_start = time.time()
            try:
                # Charger la collection
                self.milvus_service.collection.load()
                
                # D√©terminer les champs disponibles dans le sch√©ma
                schema = self.milvus_service.collection.schema
                field_names = [field.name for field in schema.fields]
                
                # On cherche les champs qui pourraient contenir les donn√©es JSON
                possible_json_fields = [field for field in field_names if field in 
                                    ["text", "metadata_json", "json_data", "data", "content"]]
                
                # Configuration des param√®tres de recherche
                search_params = {
                    "metric_type": "COSINE",
                    "params": {"nprobe": 10}
                }
                
                # Ajouter l'expression de filtrage si fournie
                search_kwargs = {
                    "data": [query_embedding],
                    "anns_field": "embedding",
                    "param": search_params,
                    "limit": actual_top_k,  # Utiliser la valeur d√©termin√©e plus haut
                    "output_fields": field_names if field_names else None
                }
                
                # Ajouter le filtre si pr√©sent
                if filter_expr:
                    search_kwargs["expr"] = filter_expr
                    logger.info(f"Recherche avec filtre: {filter_expr}")
                
                # Effectuer la recherche avec tous les param√®tres
                search_results = self.milvus_service.collection.search(**search_kwargs)
                
                # Traitement des r√©sultats
                results = []
                for hit in search_results[0]:
                    try:
                        # Structure de base du r√©sultat
                        result = {
                            "score": hit.distance,
                            "id": getattr(hit, "id", None)
                        }
                        
                        # Tenter d'extraire le texte et les m√©tadonn√©es
                        text_found = False
                        metadata_found = False
                        
                        # Essayer d'acc√©der √† l'entity
                        entity = hit.entity
                        
                        # Parcourir tous les champs disponibles
                        for field_name in dir(entity):
                            # Ignorer les attributs internes et les m√©thodes
                            if field_name.startswith('_') or callable(getattr(entity, field_name)):
                                continue
                                
                            field_value = getattr(entity, field_name)
                            
                            # Traiter le champ metadata sp√©cifiquement
                            if field_name == "metadata":
                                if isinstance(field_value, str):
                                    try:
                                        result["metadata"] = json.loads(field_value)
                                    except json.JSONDecodeError:
                                        result["metadata"] = {"document_id": "", "chunk_id": "", "filename": "Document inconnu", "page_number": 0}
                                elif isinstance(field_value, dict):
                                    result["metadata"] = field_value
                                else:
                                    result["metadata"] = {"document_id": "", "chunk_id": "", "filename": "Document inconnu", "page_number": 0}
                                metadata_found = True
                                continue
                            
                            # Essayer de traiter comme JSON si c'est une cha√Æne
                            if isinstance(field_value, str):
                                try:
                                    json_obj = json.loads(field_value)
                                    
                                    # Si c'est un JSON qui contient "text" et "metadata"
                                    if "text" in json_obj and "metadata" in json_obj:
                                        result["text"] = json_obj["text"]
                                        result["metadata"] = json_obj["metadata"]
                                        text_found = True
                                        metadata_found = True
                                    # Si c'est juste le texte
                                    elif isinstance(json_obj, str):
                                        result["text"] = json_obj
                                        text_found = True
                                    # Si c'est un autre type de JSON
                                    else:
                                        result[field_name] = json_obj
                                        
                                        # Chercher le texte et les m√©tadonn√©es dans l'objet JSON
                                        if "text" in json_obj and not text_found:
                                            result["text"] = json_obj["text"]
                                            text_found = True
                                        if "metadata" in json_obj and not metadata_found:
                                            result["metadata"] = json_obj["metadata"]
                                            metadata_found = True
                                except:
                                    # Si ce n'est pas du JSON, c'est peut-√™tre directement le texte
                                    if field_name == "text" and not text_found:
                                        result["text"] = field_value
                                        text_found = True
                                    else:
                                        result[field_name] = field_value
                            else:
                                # Pour les valeurs non-string
                                result[field_name] = field_value
                        
                        # Si aucun texte n'a √©t√© trouv√©, rechercher dans un autre format
                        if not text_found:
                            # Essayer de voir si le texte est dans un champ direct
                            for text_field in ["text", "content", "data"]:
                                if hasattr(entity, text_field):
                                    result["text"] = getattr(entity, text_field)
                                    text_found = True
                                    break
                        
                        # Si toujours pas de texte, utiliser un placeholder
                        if not text_found:
                            result["text"] = f"Document #{result.get('id', 'inconnu')}"
                        
                        # S'assurer que metadata existe toujours
                        if not metadata_found:
                            result["metadata"] = {"document_id": "", "chunk_id": "", "filename": "Document inconnu", "page_number": 0}
                        
                        results.append(result)
                        
                    except Exception as e:
                        logger.error(f"Erreur lors de l'extraction d'un r√©sultat: {str(e)}")
                        results.append({
                            "text": "Erreur d'extraction",
                            "score": hit.distance,
                            "error": str(e),
                            "metadata": {"document_id": "", "chunk_id": "", "filename": "Document inconnu", "page_number": 0}
                        })
                
                search_time = time.time() - search_start
                logger.info(f"‚è±Ô∏è Temps de recherche Milvus : {search_time:.10f}s")
                logger.info(f"‚úÖ {len(results)} documents r√©cup√©r√©s pour la requ√™te '{query}'")
                
                return results
                
            except Exception as e:
                logger.error(f"Erreur lors de la recherche: {e}")
                return []
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la recherche : {e}")
            return []
        finally:
            try:
                # Lib√©rer la collection
                self.milvus_service.collection.release()
            except:
                pass
            
            total_time = time.time() - start_time
            logger.info(f"‚è±Ô∏è Temps total de recherche: {total_time:.3f}s")

    def expand_query(self, query: str) -> List[str]:
        """
        G√©n√®re des variantes de la requ√™te pour am√©liorer la recherche juridique.
        
        Args:
            query: Requ√™te originale de l'utilisateur
            
        Returns:
            Liste des requ√™tes √©tendues, incluant l'originale
        """
        expanded_queries = [query]  # On garde toujours la requ√™te originale
        
        # Termes juridiques camerounais sp√©cifiques et leurs synonymes
        legal_synonyms = {
            "imp√¥t": ["taxation", "pr√©l√®vement fiscal", "imposition", "taxe", "IRPP", "IR"],
            "d√©claration": ["d√©claration fiscale", "formulaire fiscal", "d√©claration d'imp√¥t", "d√©claration de revenus"],
            "revenus": ["gains", "recettes", "b√©n√©fices", "r√©mun√©rations", "salaires"],
            "loi": ["l√©gislation", "texte juridique", "r√©glementation", "circulaire", "disposition l√©gale"],
            "taxe": ["imp√¥t", "redevance", "contribution", "pr√©l√®vement", "droit fiscal"],
            "entreprise": ["soci√©t√©", "√©tablissement", "personne morale", "entit√© commerciale"],
            "personne": ["individu", "contribuable", "personne physique", "assujetti"],
            "paiement": ["r√®glement", "acquittement", "versement", "paiement d'imp√¥t"],
            "exemption": ["exon√©ration", "d√©gr√®vement", "all√®gement fiscal", "dispense"],
            "obligation": ["devoir fiscal", "exigence l√©gale", "obligation fiscale", "obligation d√©clarative"]
        }
        
        # Codes sp√©cifiques camerounais et leur signification
        legal_codes = {
            "IRPP": ["Imp√¥t sur le Revenu des Personnes Physiques"],
            "IS": ["Imp√¥t sur les Soci√©t√©s"],
            "TVA": ["Taxe sur la Valeur Ajout√©e"],
            "DGI": ["Direction G√©n√©rale des Imp√¥ts"],
            "CGI": ["Code G√©n√©ral des Imp√¥ts"],
            "TPF": ["Taxe Professionnelle Fonci√®re"],
            "TPR": ["Taxe Professionnelle de Redevance"],
            "TDL": ["Taxe de D√©veloppement Local"]
        }
        
        try:
            import re
            
            # 1. Expansion bas√©e sur les synonymes juridiques
            query_words = re.findall(r'\w+', query.lower())
            for word in query_words:
                for key, synonyms in legal_synonyms.items():
                    if word == key or word in [s.lower() for s in synonyms]:
                        # Ajouter des variantes avec synonymes
                        for synonym in synonyms:
                            new_query = re.sub(r'\b' + re.escape(word) + r'\b', synonym, query, flags=re.IGNORECASE)
                            if new_query != query and new_query not in expanded_queries:
                                expanded_queries.append(new_query)
            
            # 2. Expansion bas√©e sur les codes juridiques camerounais
            for code, meanings in legal_codes.items():
                if code in query.upper():
                    # Remplacer le code par sa signification
                    for meaning in meanings:
                        new_query = re.sub(r'\b' + re.escape(code) + r'\b', meaning, query, flags=re.IGNORECASE)
                        if new_query not in expanded_queries:
                            expanded_queries.append(new_query)
                # Chercher si une signification est dans la requ√™te
                for meaning in meanings:
                    if meaning.lower() in query.lower():
                        # Remplacer la signification par le code
                        new_query = re.sub(r'\b' + re.escape(meaning) + r'\b', code, query, flags=re.IGNORECASE)
                        if new_query not in expanded_queries:
                            expanded_queries.append(new_query)
            
            # 3. Expansion sp√©cifique pour les documents juridiques camerounais
            if any(term in query.lower() for term in ["d√©claration", "imp√¥t", "revenu", "irpp"]):
                expanded_queries.append("d√©claration IRPP cameroun")
                expanded_queries.append("formulaire d√©claration imp√¥t")
                expanded_queries.append("d√©claration fiscale revenu")
            
            if "taxe" in query.lower() or "imp√¥t" in query.lower():
                expanded_queries.append(query + " cameroun")
                expanded_queries.append(query + " code g√©n√©ral des imp√¥ts")
                expanded_queries.append(query + " loi fiscale")
            
            # 4. Rechercher des sections sp√©cifiques si la requ√™te semble cibler un article
            article_match = re.search(r'\barticle\s+(\d+)\b', query.lower())
            if article_match:
                article_num = article_match.group(1)
                expanded_queries.append(f"article {article_num}")
                expanded_queries.append(f"Art. {article_num}")
                expanded_queries.append(f"ARTICLE {article_num}")
            
            logger.info(f"Expansion de requ√™te: {query} -> {expanded_queries}")
            return expanded_queries
            
        except Exception as e:
            logger.error(f"Erreur lors de l'expansion de requ√™te: {e}")
            return [query]  # Retourner la requ√™te originale en cas d'erreur
        
    def search_with_expansion(self, query: str, top_k: int = None, filter_expr: str = None) -> List[Dict[str, Any]]:
        """
        Recherche des documents pertinents avec expansion de requ√™te adapt√©e aux documents juridiques.
        
        Args:
            query: La requ√™te de l'utilisateur
            
        Returns:
            Liste de dictionnaires contenant les documents trouv√©s avec leurs m√©tadonn√©es
        """
        try:
                # G√©n√©rer des variantes de la requ√™te
            expanded_queries = self.expand_query(query)
            
            # R√©sultats combin√©s de toutes les recherches
            all_results = []
            seen_chunks = set()  # √âviter les doublons par chunk_id
            seen_docs = set()    # Suivre les documents uniques
            doc_count = {}       # Compter les apparitions par document_id
            
            # D'abord, chercher avec la requ√™te originale
            original_results = self.search(query=query,
                top_k=top_k,
                filter_expr=filter_expr
            )
            if original_results:
                for result in original_results:
                    metadata = result.get("metadata", {})
                    chunk_id = metadata.get("chunk_id", "")
                    doc_id = metadata.get("document_id", "")
                    
                    if doc_id:
                        doc_count[doc_id] = doc_count.get(doc_id, 0) + 1
                        seen_docs.add(doc_id)
                    
                    if chunk_id and chunk_id not in seen_chunks:
                        seen_chunks.add(chunk_id)
                        result["matched_query"] = query  # Requ√™te originale
                        all_results.append(result)
            
            # Ensuite, essayer les requ√™tes d'expansion (sauf la requ√™te originale)
            for expanded_query in [q for q in expanded_queries if q != query]:
                try:
                    results = self.search(expanded_query)
                    
                    # Ajouter les nouveaux r√©sultats
                    for result in results:
                        metadata = result.get("metadata", {})
                        chunk_id = metadata.get("chunk_id", "")
                        doc_id = metadata.get("document_id", "")
                        
                        if doc_id:
                            doc_count[doc_id] = doc_count.get(doc_id, 0) + 1
                            seen_docs.add(doc_id)
                        
                        if chunk_id and chunk_id not in seen_chunks:
                            seen_chunks.add(chunk_id)
                            result["matched_query"] = expanded_query
                            all_results.append(result)
                except Exception as e:
                    # Ne pas √©chouer si une requ√™te d'expansion √©choue
                    logger.warning(f"√âchec de l'expansion '{expanded_query}': {e}")
                    continue
            
            # Si aucun r√©sultat trouv√©, retourner au moins les r√©sultats originaux
            if not all_results and original_results:
                return original_results
                
                # Limiter au nombre de r√©sultats demand√©s
            return all_results
            
        except Exception as e:
            logger.error(f"Erreur lors de la recherche avec expansion: {e}")
            # Fallback √† la recherche standard
            return self.search(query)

    def _group_results_by_document(self, results: List[Dict[str, Any]], top_docs: List[str]) -> List[Dict[str, Any]]:
        """
        R√©organise les r√©sultats pour favoriser la coh√©rence documentaire.
        Maintient la pertinence globale tout en groupant les chunks du m√™me document.
        
        Args:
            results: Liste des r√©sultats √† r√©organiser
            top_docs: Liste des IDs des documents les plus pertinents
            
        Returns:
            Liste r√©organis√©e des r√©sultats
        """
        if not results:
            return []
        
        # Organiser les r√©sultats par document
        doc_results = {}
        for result in results:
            doc_id = result.get("metadata", {}).get("document_id", "unknown")
            if doc_id not in doc_results:
                doc_results[doc_id] = []
            doc_results[doc_id].append(result)
        
        # Trier les r√©sultats de chaque document par score
        for doc_id in doc_results:
            doc_results[doc_id].sort(key=lambda x: x.get("score", 0), reverse=True)
        
        # R√©organiser les r√©sultats en favorisant les top documents
        # mais en maintenant une diversit√© globale
        grouped = []
        
        # D'abord, ajouter les meilleurs r√©sultats de chaque document important
        for doc_id in top_docs:
            if doc_id in doc_results and doc_results[doc_id]:
                grouped.append(doc_results[doc_id][0])  # Meilleur r√©sultat
                doc_results[doc_id] = doc_results[doc_id][1:]  # Retirer le meilleur
        
        # Ensuite, ajouter les autres r√©sultats en alternant les documents
        # pour maintenir une diversit√© documentaire
        remaining_docs = list(doc_results.keys())
        while remaining_docs:
            for doc_id in remaining_docs[:]:
                if doc_results[doc_id]:
                    grouped.append(doc_results[doc_id][0])
                    doc_results[doc_id] = doc_results[doc_id][1:]
                    
                    if not doc_results[doc_id]:
                        remaining_docs.remove(doc_id)
        
        return grouped


    

if __name__ == "__main__":
    # Cr√©ation des services
    milvus_service = MilvusService(
        collection_name="documents_collection", 
        dim=1024  # Assurez-vous que cette dimension correspond √† votre mod√®le d'embedding
    )
    embedding_service = EmbeddingService()
    search_service = SearchService(milvus_service, embedding_service, top_k=5)

    # Interface utilisateur simple
    print("\n=== Syst√®me de recherche documentaire ===\n")
    
    while True:
        query = input("\nEntrez votre requ√™te de recherche (tapez 'exit' pour quitter) : ")
        if query.lower() == 'exit':
            print("Au revoir!")
            break
            
        if not query.strip():
            print("Veuillez entrer une requ√™te valide.")
            continue
            
        # Effectuer la recherche
        start_time = time.time()
        results = search_service.search(query)
        total_time = time.time() - start_time
        
        # Afficher les r√©sultats
        print(f"\nüîç Documents trouv√©s ({total_time:.3f}s):")
        
        if not results:
            print("Aucun document pertinent trouv√©.")
        else:
            for i, result in enumerate(results, 1):
                # Extraire les informations
                text = result.get("text", "Texte non disponible")
                score = result.get("score", 0.0)
                metadata = result.get("metadata", {})
                
                # Extraire les m√©tadonn√©es pertinentes si disponibles
                filename = metadata.get("filename", "Document inconnu")
                page = metadata.get("page_number", "?")
                
                # Afficher un extrait du texte (max 100 caract√®res)
                text_preview = text[:100] + "..." if len(text) > 100 else text
                
                print(f"{i}. [{score:.2f}] {filename} (p.{page}): {text_preview}")